<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Implementation details</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rack-logo-110x55.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Sections</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Implementation details </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="details"></a>
Internal data structure</h1>
<p>Internally, radar data is stored in a tree-like hierarchical structure very analogous to that of Hierarchical Data Format (hdf5) itself. Rack also takes advantage of the OPERA Data Model (ODIM, <a href="http://eumetnet.eu/wp-content/uploads/2017/01/OPERA_hdf_description_2014.pdf">http://eumetnet.eu/wp-content/uploads/2017/01/OPERA_hdf_description_2014.pdf</a>), an encoding and naming policy applicable in HDF5 for different types of radar data like azimuthal scans, polar products and Cartesian images .</p>
<p>In <code>Rack</code>, an HDF5 file is primarily stored using drain::Tree&lt;T&gt; structure, a tree where each node essentially consists of a data array and a map of attributes. The data array is implemented with drain::Image, an image class based on std::vector&lt;T&gt;. The images can use any storage type from <code>unsigned</code> char to  double . The attributes are stored as a <a class="el" href="classdrain_1_1VariableMap.html" title="A map of Variables. ">drain::VariableMap</a> , which is essentially an stl::map&lt;T&gt; of references to scalar variables, arrays, and strings (std::string). Practically, in each node either the data array or attributes are applied (ie. non-empty). Specifically, <code>/datasetN</code> , <code>/dataN</code> , <code>/what</code> , <code>/where</code> , and <code>/how</code> Groups contain only attributes but the data is empty whereas in <code>/data</code> Group the data array is non-zero but the attribute map is empty.</p>
<h1><a class="anchor" id="imageprocessing"></a>
Processing two-dimensional data</h1>
<p>For anomaly detection and removal as well as for meteorological products, all the processing is done in polar coordinate system, ie. the native system for radars. At the edges of the data arrays, coordinate handlers (drain::image::CoordinateHandler) quarantee that the coordinates are properly wrapped. This is needed by functions applying pixel neighbourhoods, such as those applying moving windows or spatial recursion.</p>
<p>Smoothing operations (<a class="el" href="classdrain_1_1image_1_1FastAverageOp.html" title="Sliding window averaging operator with optional weighting support. ">drain::image::FastAverageOp</a>, drain::image::FastMedianOp) apply rectangular moving windows which are updated incrementally, yelding a remarkable speedup. Functions not applying pixel neighbourhoods apply direct, one-dimensional memory iteration whenever possible. The segment size analysis (<a class="el" href="namespacedrain_1_1image.html" title="Namespace for images and image processing tools. ">drain::image</a>:SegmentSizeOp) applies a semi-recursive floodfill technique, which combines a non-recursive horizontal traversal with a recursive vertical traversal; this keeps stack size small.</p>
<p>Internally some <b>AnDRe</b> detectors require that incoming data be in unsigned-char type with a fixed scaling (<code>gain</code> =1.0/250.0, <code>offset</code> =-32.0) and special codes (<code>undetect</code> =0, <code>nodata</code> =255). When needed, <b>Andre</b> performs this conversion automatically, storing the converted copy in a path suffixed with tilde '~'. These auxiliary data will not be included in output files unless a high debugging mode is selected with <code>&ndash;verbose</code> . The removal operations apply to the original data.</p>
<p>Instead of strict thresholding, the detectors apply frequently fuzzy functions ie. functions that map quantity ranges to continuous truth values between 0.0 (no) and 1.0 (yes). Then, conditions like "the dBZ is over 20" and "width of the speck is about 1500m" can be combined by multiplying associated fuzzy functions; the result is a combined truth value. The fuzzy functions applied in <b>AnDRe</b> are fuzzy peak (drain::FuzzyPeak) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_{\mathrm{p}}(x) = \frac{a^2}{a^2 + x^2} \]" src="form_21.png"/>
</p>
<p> where <img class="formulaInl" alt="$a$" src="form_22.png"/> is the width, and fuzzy threshold (<a class="el" href="classdrain_1_1FuzzyStep.html" title="A basic, linear transition from 0 to scale between (start) and (end) . ">drain::FuzzyStep</a>) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_{\mathrm{th}}(x) = \frac{1}{2} + \frac{x}{2(a + |x|)}. \]" src="form_23.png"/>
</p>
<p> where <img class="formulaInl" alt="$a$" src="form_22.png"/> is the steepness.</p>
<div class="image">
<img src="fuzzies.png" alt="fuzzies.png"/>
<div class="caption">
Fuzzy peak and threshold functions.</div></div>
  </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
